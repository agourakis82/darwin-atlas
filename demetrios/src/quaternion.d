/// Quaternion Lift and Dicyclic Groups
///
/// Implementation of the double cover Dic_n → D_n
/// for verifying algebraic structure of genomic symmetries.

module quaternion;

use std.math::{sin, cos, PI};

/// Quaternion representation: q = w + xi + yj + zk
pub struct Quaternion {
    pub w: f64,  // Scalar part
    pub x: f64,  // i component
    pub y: f64,  // j component
    pub z: f64,  // k component
}

impl Quaternion {
    pub fn new(w: f64, x: f64, y: f64, z: f64) -> Self {
        Quaternion { w, x, y, z }
    }

    pub fn identity() -> Self {
        Quaternion::new(1.0, 0.0, 0.0, 0.0)
    }

    pub fn neg_identity() -> Self {
        Quaternion::new(-1.0, 0.0, 0.0, 0.0)
    }

    /// Quaternion multiplication (Hamilton product)
    pub fn mul(&self, other: &Quaternion) -> Quaternion {
        Quaternion::new(
            self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z,
            self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y,
            self.w * other.y - self.x * other.z + self.y * other.w + self.z * other.x,
            self.w * other.z + self.x * other.y - self.y * other.x + self.z * other.w,
        )
    }

    /// Negation: -q
    pub fn neg(&self) -> Quaternion {
        Quaternion::new(-self.w, -self.x, -self.y, -self.z)
    }

    /// Check approximate equality
    pub fn approx_eq(&self, other: &Quaternion, tol: f64) -> bool {
        (self.w - other.w).abs() < tol &&
        (self.x - other.x).abs() < tol &&
        (self.y - other.y).abs() < tol &&
        (self.z - other.z).abs() < tol
    }
}

/// Dicyclic group Dic_n
/// Generated by a, b with relations:
/// - a^{2n} = 1
/// - b^2 = a^n
/// - b^{-1}ab = a^{-1}
pub struct DicyclicGroup {
    pub n: usize,
}

impl DicyclicGroup {
    pub fn new(n: usize) -> Self {
        assert!(n >= 2, "Dicyclic group requires n >= 2");
        DicyclicGroup { n }
    }

    /// Order of the group: |Dic_n| = 4n
    pub fn order(&self) -> usize {
        4 * self.n
    }
}

/// Element of Dic_n represented as a^k or a^k * b
pub struct DicyclicElement {
    pub q: Quaternion,
}

/// Generate dicyclic group element
/// k: power of generator a
/// is_reflection: whether to multiply by b
pub fn dicyclic_element(g: &DicyclicGroup, k: usize, is_reflection: bool) -> DicyclicElement {
    let n = g.n;
    let theta = PI * k as f64 / n as f64;

    // a = exp(πi/n) as unit quaternion
    let a_k = Quaternion::new(cos(theta), sin(theta), 0.0, 0.0);

    if is_reflection {
        // b = j in quaternion representation
        let b = Quaternion::new(0.0, 0.0, 1.0, 0.0);
        DicyclicElement { q: a_k.mul(&b) }
    } else {
        DicyclicElement { q: a_k }
    }
}

/// Project quaternion to dihedral group element
/// Returns (rotation_index, is_reflection)
pub fn project_to_dihedral(elem: &DicyclicElement, g: &DicyclicGroup) -> (usize, bool) {
    let q = &elem.q;
    let n = g.n;

    // Check if rotation (z=0) or reflection (y≠0 or z≠0)
    let is_reflection = q.y.abs() > 1e-10 || q.z.abs() > 1e-10;

    // Extract rotation angle from w + xi part
    let angle = q.x.atan2(q.w);
    let k = ((angle * n as f64 / PI).round() as isize).rem_euclid(n as isize) as usize;

    (k, is_reflection)
}

/// Verify that Dic_n is a double cover of D_n
/// Check: for each g ∈ Dic_n, both g and -g project to same D_n element
pub fn verify_double_cover(g: &DicyclicGroup) -> bool {
    let n = g.n;

    for k in 0..(2*n) {
        for is_ref in [false, true] {
            let elem = dicyclic_element(g, k, is_ref);
            let neg_elem = DicyclicElement { q: elem.q.neg() };

            let proj1 = project_to_dihedral(&elem, g);
            let proj2 = project_to_dihedral(&neg_elem, g);

            if proj1 != proj2 {
                return false;
            }
        }
    }

    true
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_quaternion_identity() {
        let id = Quaternion::identity();
        let q = Quaternion::new(1.0, 2.0, 3.0, 4.0);
        assert!(id.mul(&q).approx_eq(&q, 1e-10));
    }

    #[test]
    fn test_dicyclic_order() {
        let g = DicyclicGroup::new(4);
        assert_eq!(g.order(), 16);
    }

    #[test]
    fn test_double_cover() {
        for n in 2..=8 {
            let g = DicyclicGroup::new(n);
            assert!(verify_double_cover(&g));
        }
    }
}
