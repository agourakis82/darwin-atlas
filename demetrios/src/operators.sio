/// Genomic Sequence Operators
///
/// Mathematical definitions of operators acting on DNA sequences.
/// These form the generators of the dihedral group D_n.

module operators;

/// DNA base type with 2-bit encoding (using u8 with masking)
/// A=0b00, C=0b01, G=0b10, T=0b11
type Base = u8;

const A: Base = 0b00;
const C: Base = 0b01;
const G: Base = 0b10;
const T: Base = 0b11;

/// DNA sequence as packed 2-bit array
type Sequence = [Base];



/// Shift operator S: σ(i) = s_{(i+1) mod n}
/// Generates cyclic group C_n
#[inline]
pub fn shift(seq: &Sequence, k: usize) -> Sequence {
    let n = seq.len();
    if n == 0 { return []; }
    let k = k % n;
    // Use slicing and concatenation
    seq[k..] ++ seq[..k]
}

/// Reverse operator R: σ(i) = s_{n-1-i}
/// Order 2 element, R^2 = I
#[inline]
pub fn reverse(seq: &Sequence) -> Sequence {
    let n = seq.len();
    var result: Sequence = [];
    var i: usize = n;
    while i > 0 {
        i = i - 1;
        result = result ++ [seq[i]];
    }
    result
}

/// Complement operator K: σ(i) = complement(s_i)
/// A↔T, C↔G
#[inline]
pub fn complement_base(b: Base) -> Base {
    // XOR with 0b11 swaps A↔T and C↔G
    // Mask to 2 bits
    (b ^ 0b11) & 0b11
}

#[inline]
pub fn complement(seq: &Sequence) -> Sequence {
    var result: Sequence = [];
    var i: usize = 0;
    while i < seq.len() {
        result = result ++ [complement_base(seq[i])];
        i = i + 1;
    }
    result
}

/// Reverse complement RC = R ∘ K = K ∘ R
/// Biologically: opposite strand reading
#[inline]
pub fn reverse_complement(seq: &Sequence) -> Sequence {
    complement(reverse(seq))
}

/// Hamming distance between two sequences
#[inline]
pub fn hamming_distance(a: &Sequence, b: &Sequence) -> usize {
    assert!(a.len() == b.len(), "Sequences must have equal length");
    var count: usize = 0;
    var i: usize = 0;
    while i < a.len() {
        if a[i] != b[i] {
            count = count + 1;
        }
        i = i + 1;
    }
    count
}
