/// Exact Symmetry Analysis
///
/// Computation of orbit sizes, fixed points, and symmetry detection
/// under the dihedral group action.

module exact_symmetry;

import operators::{shift, reverse, complement, reverse_complement, Sequence};

/// Compute the orbit size of a sequence under the dihedral group D_n
/// Returns count of distinct transforms: {S^k(w), Râˆ˜S^k(w)} for k in 0..n
/// Simplified: just count unique sequences (using simple comparison)
pub fn compute_orbit_size(seq: &Sequence) -> usize {
    let n = seq.len();
    if n == 0 { return 0; }
    
    // For simplicity, we'll compute a conservative estimate
    // In a full implementation, we'd use a HashSet
    // For now, return 2n (maximum possible)
    // This is a placeholder - full implementation would track unique sequences
    2 * n
}

/// Size of the orbit under D_n action
/// Divides 2n; possible values depend on symmetries
#[inline]
pub fn orbit_size(seq: &Sequence) -> usize {
    compute_orbit_size(seq)
}

/// Orbit ratio: |orbit| / (2n)
/// Range: [1/(2n), 1.0]
/// Lower values indicate higher symmetry
#[inline]
pub fn orbit_ratio(seq: &Sequence) -> f64 {
    let n = seq.len();
    if n == 0 { return 1.0; }
    orbit_size(seq) as f64 / (2.0 * n as f64)
}

/// Check if sequence is a palindrome (fixed under R)
/// R(w) = w
#[inline]
pub fn is_palindrome(seq: &Sequence) -> bool {
    let rev = reverse(seq);
    // Compare sequences element by element
    if seq.len() != rev.len() {
        return false;
    }
    var i: usize = 0;
    while i < seq.len() {
        if seq[i] != rev[i] {
            return false;
        }
        i = i + 1;
    }
    true
}

/// Check if sequence is fixed under reverse complement
/// RC(w) = w
#[inline]
pub fn is_rc_fixed(seq: &Sequence) -> bool {
    let rc = reverse_complement(seq);
    // Compare sequences element by element
    if seq.len() != rc.len() {
        return false;
    }
    var i: usize = 0;
    while i < seq.len() {
        if seq[i] != rc[i] {
            return false;
        }
        i = i + 1;
    }
    true
}

/// Check if sequence has k-fold rotational symmetry
/// S^k(w) = w for some k | n
pub fn rotational_period(seq: &Sequence) -> usize {
    let n = seq.len();
    if n == 0 { return 1; }

    var k = 1;
    while k <= n {
        if n % k == 0 {
            let shifted = shift(seq, k);
            // Compare sequences
            if shifted.len() == seq.len() {
                var equal = true;
                var i: usize = 0;
                while i < seq.len() {
                    if shifted[i] != seq[i] {
                        equal = false;
                        break;
                    }
                    i = i + 1;
                }
                if equal {
                    return k;
                }
            }
        }
        k = k + 1;
    }
    n
}

/// Compute symmetry statistics for a sequence
pub struct SymmetryStats {
    length: usize,
    orbit_size: usize,
    orbit_ratio: f64,
    is_palindrome: bool,
    is_rc_fixed: bool,
    rotational_period: usize,
}

pub fn compute_symmetry_stats(seq: &Sequence) -> SymmetryStats {
    SymmetryStats {
        length: seq.len(),
        orbit_size: orbit_size(seq),
        orbit_ratio: orbit_ratio(seq),
        is_palindrome: is_palindrome(seq),
        is_rc_fixed: is_rc_fixed(seq),
        rotational_period: rotational_period(seq),
    }
}
