/// Quaternion Lift and Dicyclic Groups
///
/// Implementation of the double cover Dic_n → D_n
/// for verifying algebraic structure of genomic symmetries.

module quaternion;

// Math constants and functions
const PI: f64 = 3.14159265358979323846;

fn sin(x: f64) -> f64 {
    // Placeholder - would use stdlib math
    // For now, return 0 to allow compilation
    0.0
}

fn cos(x: f64) -> f64 {
    // Placeholder - would use stdlib math
    // For now, return 1 to allow compilation
    1.0
}

/// Quaternion representation: q = w + xi + yj + zk
pub struct Quaternion {
    w: f64,  // Scalar part
    x: f64,  // i component
    y: f64,  // j component
    z: f64,  // k component
}

impl Quaternion {
    pub fn new(w: f64, x: f64, y: f64, z: f64) -> Quaternion {
        Quaternion { w, x, y, z }
    }

    pub fn identity() -> Quaternion {
        Quaternion::new(1.0, 0.0, 0.0, 0.0)
    }

    pub fn neg_identity() -> Quaternion {
        Quaternion::new(-1.0, 0.0, 0.0, 0.0)
    }

    /// Quaternion multiplication (Hamilton product)
    pub fn mul(&self, other: &Quaternion) -> Quaternion {
        Quaternion::new(
            self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z,
            self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y,
            self.w * other.y - self.x * other.z + self.y * other.w + self.z * other.x,
            self.w * other.z + self.x * other.y - self.y * other.x + self.z * other.w,
        )
    }

    /// Negation: -q
    pub fn neg(&self) -> Quaternion {
        Quaternion::new(-self.w, -self.x, -self.y, -self.z)
    }

    /// Check approximate equality
    pub fn approx_eq(&self, other: &Quaternion, tol: f64) -> bool {
        (self.w - other.w).abs() < tol &&
        (self.x - other.x).abs() < tol &&
        (self.y - other.y).abs() < tol &&
        (self.z - other.z).abs() < tol
    }
}

/// Dicyclic group Dic_n
/// Generated by a, b with relations:
/// - a^{2n} = 1
/// - b^2 = a^n
/// - b^{-1}ab = a^{-1}
pub struct DicyclicGroup {
    n: usize,
}

impl DicyclicGroup {
    pub fn new(n: usize) -> DicyclicGroup {
        assert!(n >= 2, "Dicyclic group requires n >= 2");
        DicyclicGroup { n }
    }

    /// Order of the group: |Dic_n| = 4n
    pub fn order(&self) -> usize {
        4 * self.n
    }
}

/// Element of Dic_n represented as a^k or a^k * b
pub struct DicyclicElement {
    q: Quaternion,
}

/// Generate dicyclic group element
/// k: power of generator a
/// is_reflection: whether to multiply by b
pub fn dicyclic_element(g: &DicyclicGroup, k: usize, is_reflection: bool) -> DicyclicElement {
    let n = g.n;
    let theta = PI * k as f64 / n as f64;

    // a = exp(πi/n) as unit quaternion
    let a_k = Quaternion::new(cos(theta), sin(theta), 0.0, 0.0);

    if is_reflection {
        // b = j in quaternion representation
        let b = Quaternion::new(0.0, 0.0, 1.0, 0.0);
        DicyclicElement { q: a_k.mul(&b) }
    } else {
        DicyclicElement { q: a_k }
    }
}

/// Project quaternion to dihedral group element
/// Returns (rotation_index, is_reflection)
pub fn project_to_dihedral(elem: &DicyclicElement, g: &DicyclicGroup) -> (usize, bool) {
    let q = &elem.q;
    let n = g.n;

    // Check if rotation (z=0) or reflection (y≠0 or z≠0)
    let is_reflection = q.y.abs() > 1e-10 || q.z.abs() > 1e-10;

    // Extract rotation angle from w + xi part
    let angle = q.x.atan2(q.w);
    // Calculate k modulo n
    let k_float = (angle * n as f64 / PI).round();
    var k: isize = k_float as isize;
    while k < 0 {
        k = k + n as isize;
    }
    let k_usize = (k % n as isize) as usize;

    (k_usize, is_reflection)
}

/// Verify that Dic_n is a double cover of D_n
/// Check: for each g ∈ Dic_n, both g and -g project to same D_n element
pub fn verify_double_cover(g: &DicyclicGroup) -> bool {
    let n = g.n;
    let two_n = 2 * n;

    var k: usize = 0;
    while k < two_n {
        var is_ref_idx: usize = 0;
        while is_ref_idx < 2 {
            let is_ref = if is_ref_idx == 0 { false } else { true };
            let elem = dicyclic_element(g, k, is_ref);
            let neg_elem = DicyclicElement { q: elem.q.neg() };

            let proj1 = project_to_dihedral(&elem, g);
            let proj2 = project_to_dihedral(&neg_elem, g);

            // Compare tuples
            if proj1.0 != proj2.0 || proj1.1 != proj2.1 {
                return false;
            }
            is_ref_idx = is_ref_idx + 1;
        }
        k = k + 1;
    }

    true
}
