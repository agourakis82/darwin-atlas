/// Approximate Symmetry Metric
///
/// Computation of d_min/L: minimum normalized Hamming distance
/// to any non-identity dihedral transform.

module approx_metric;

import operators::{shift, reverse, reverse_complement, hamming_distance, Sequence};

/// Minimum distance to any non-identity transform in the dihedral group
/// d_min(w) = min_{g ∈ D_n \ {id}} H(w, g(w))
///
/// Transforms tested:
/// - S^k for k in 1..n (cyclic shifts, excluding identity)
/// - R∘S^k for k in 0..n (reverse then shift)
/// - RC∘S^k for k in 0..n (reverse complement then shift, if include_rc)
pub fn dmin(seq: &Sequence, include_rc: bool) -> usize {
    let n = seq.len();
    if n == 0 { return 0; }

    var min_dist: usize = n;  // Maximum possible

    // S^k transforms (k=1..n-1, excluding identity k=0)
    var k: usize = 1;
    while k < n {
        let shifted = shift(seq, k);
        let d = hamming_distance(seq, &shifted);
        if d < min_dist {
            min_dist = d;
        }
        k = k + 1;
    }

    // R∘S^k transforms (k=0..n-1)
    let rev = reverse(seq);
    k = 0;
    while k < n {
        let shifted_rev = shift(&rev, k);
        let d = hamming_distance(seq, &shifted_rev);
        if d < min_dist {
            min_dist = d;
        }
        k = k + 1;
    }

    // RC∘S^k transforms (optional)
    if include_rc {
        let rc = reverse_complement(seq);
        k = 0;
        while k < n {
            let shifted_rc = shift(&rc, k);
            let d = hamming_distance(seq, &shifted_rc);
            if d < min_dist {
                min_dist = d;
            }
            k = k + 1;
        }
    }

    min_dist
}

/// Normalized d_min: d_min / L
/// Range: [0, 1] where 0 = exact symmetry, 1 = maximum asymmetry
#[inline]
pub fn dmin_normalized(seq: &Sequence, include_rc: bool) -> f64 {
    let n = seq.len();
    if n == 0 { return 0.0; }
    dmin(seq, include_rc) as f64 / n as f64
}

/// Identify which transform achieves d_min
pub enum NearestTransform {
    Shift(usize),           // S^k
    ReverseShift(usize),    // R∘S^k
    RCShift(usize),         // RC∘S^k
}

pub fn nearest_transform(seq: &Sequence, include_rc: bool) -> (usize, NearestTransform) {
    let n = seq.len();
    if n == 0 { 
        let nearest = NearestTransform::Shift(0);
        return (0, nearest);
    }

    var min_dist: usize = n;
    var nearest = NearestTransform::Shift(1);

    // S^k transforms
    var k: usize = 1;
    while k < n {
        let d = hamming_distance(seq, &shift(seq, k));
        if d < min_dist {
            min_dist = d;
            nearest = NearestTransform::Shift(k);
        }
        k = k + 1;
    }

    // R∘S^k transforms
    let rev = reverse(seq);
    k = 0;
    while k < n {
        let d = hamming_distance(seq, &shift(&rev, k));
        if d < min_dist {
            min_dist = d;
            nearest = NearestTransform::ReverseShift(k);
        }
        k = k + 1;
    }

    // RC∘S^k transforms
    if include_rc {
        let rc = reverse_complement(seq);
        k = 0;
        while k < n {
            let d = hamming_distance(seq, &shift(&rc, k));
            if d < min_dist {
                min_dist = d;
                nearest = NearestTransform::RCShift(k);
            }
            k = k + 1;
        }
    }

    (min_dist, nearest)
}
