"""
    QuaternionLift.jl

Dicyclic group Dic_n and quaternion representations.

Implements the double cover Dic_n → D_n for verifying
algebraic structure of genomic symmetries.
"""

using Quaternions: Quaternion, quat

"""
    DicyclicGroup

The dicyclic group Dic_n of order 4n.

Generated by elements a, b with relations:
- a^{2n} = 1
- b² = aⁿ
- b⁻¹ab = a⁻¹

Dic_n is a double cover of the dihedral group D_n.
"""
struct DicyclicGroup
    n::Int

    function DicyclicGroup(n::Int)
        n >= 2 || error("Dicyclic group requires n ≥ 2")
        new(n)
    end
end

"""
    order(g::DicyclicGroup) -> Int

Order of the dicyclic group: |Dic_n| = 4n.
"""
order(g::DicyclicGroup) = 4 * g.n

"""
    DicyclicElement

Element of Dic_n represented as a unit quaternion.
"""
struct DicyclicElement
    q::Quaternion{Float64}
end

"""
    dicyclic_element(g::DicyclicGroup, k::Int, is_reflection::Bool) -> DicyclicElement

Generate a dicyclic group element.

# Arguments
- `g`: The dicyclic group Dic_n
- `k`: Power of generator a (0 ≤ k < 2n)
- `is_reflection`: Whether to multiply by b

# Returns
Element a^k (if is_reflection=false) or a^k·b (if is_reflection=true),
represented as a unit quaternion.
"""
function dicyclic_element(g::DicyclicGroup, k::Int, is_reflection::Bool)::DicyclicElement
    n = g.n
    θ = π * k / n

    # a = exp(πi/n) as unit quaternion
    a_k = quat(cos(θ), sin(θ), 0.0, 0.0)

    if is_reflection
        # b = j in quaternion representation
        b = quat(0.0, 0.0, 1.0, 0.0)
        return DicyclicElement(a_k * b)
    else
        return DicyclicElement(a_k)
    end
end

"""
    project_to_dihedral(elem::DicyclicElement, g::DicyclicGroup) -> Tuple{Int, Bool}

Project a dicyclic element to dihedral group D_n.

# Returns
Tuple (k, is_reflection) where the D_n element is:
- r^k (rotation) if is_reflection = false
- r^k·s (reflection) if is_reflection = true
"""
function project_to_dihedral(elem::DicyclicElement, g::DicyclicGroup)::Tuple{Int, Bool}
    q = elem.q
    n = g.n

    # Check if reflection (has j or k component)
    is_reflection = abs(imag_part(q)[2]) > 1e-10 || abs(imag_part(q)[3]) > 1e-10

    # Extract rotation angle from w + xi part
    angle = atan(imag_part(q)[1], real(q))
    k = mod(round(Int, angle * n / π), n)

    return (k, is_reflection)
end

# Helper to extract imaginary parts
imag_part(q::Quaternion) = (q.v1, q.v2, q.v3)

"""
    verify_double_cover(g::DicyclicGroup) -> Bool

Verify that Dic_n is a double cover of D_n.

Checks that for each element q ∈ Dic_n, both q and -q
project to the same element in D_n.
"""
function verify_double_cover(g::DicyclicGroup)::Bool
    n = g.n

    for k in 0:(2*n - 1)
        for is_ref in [false, true]
            elem = dicyclic_element(g, k, is_ref)
            neg_elem = DicyclicElement(quat(-real(elem.q), -imag_part(elem.q)...))

            proj1 = project_to_dihedral(elem, g)
            proj2 = project_to_dihedral(neg_elem, g)

            if proj1 != proj2
                return false
            end
        end
    end

    return true
end

"""
    all_elements(g::DicyclicGroup) -> Vector{DicyclicElement}

Generate all elements of the dicyclic group.
"""
function all_elements(g::DicyclicGroup)::Vector{DicyclicElement}
    elements = DicyclicElement[]

    for k in 0:(2*g.n - 1)
        push!(elements, dicyclic_element(g, k, false))
        push!(elements, dicyclic_element(g, k, true))
    end

    return elements
end
